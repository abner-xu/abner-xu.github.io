<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="XuChen的博客">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://xuchen.youtuc.cn">
    <!--SEO-->

    <meta name="keywords" content="docker、PHP、Golang、Redis、MySQL、Web面试；">


    <meta name="description" content="+号拼接这种拼接最简单，也最容易被我们使用，因为它是不限编程语言的，比如Go语言有，Java也有，它们是+号运算符，在运行时计算的。现在演示下这种拼接的代码，虽然比较简单。
1234567fun...">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">

    <!--Title-->


<title>Go基础-字符串高效拼 | XuChen的博客</title>


    <link rel="alternate" href="/atom.xml" title="XuChen的博客" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    



    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?312e8b385d973dd9c15c283aa84ea6a8";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>



    

    <script>
        (function(){
            var bp = document.createElement('script');
            var curProtocol = window.location.protocol.split(':')[0];
            if (curProtocol === 'https') {
                bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
            }
            else {
                bp.src = 'http://push.zhanzhang.baidu.com/push.js';
            }
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(bp, s);
        })();
    </script>

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  style="background-image:url(http://ww1.sinaimg.cn/large/0078bOVFgy1g0xp1zlruqj30zk05a0un.jpg);background-repeat:round;"  >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='abner'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                <h2> 待到风起时，扬帆济沧海 </h2>
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://xuchen.youtuc.cn">XuChen的博客</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/后端/"><i class="fa "></i>后端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/前端/"><i class="fa "></i>前端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/工具/"><i class="fa "></i>工具</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/archives/"><i class="fa "></i>归档</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container-fluid">
            <div class="row">
                <main class="col-xs-12 col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="Go基础-字符串高效拼">
            
	            Go基础-字符串高效拼
            
        </h1>
        <div class="post-meta">
    
        <span class="categories-meta fa-wrap">
            <i class="fa fa-folder-open-o"></i>
            <a class="category-link" href="/categories/后端/">后端</a> <a class="category-link" href="/categories/后端/Golang/">Golang</a>
        </span>
    

    
        <span class="fa-wrap">
            <i class="fa fa-tags"></i>
            <span class="tags-meta">
                
            </span>
        </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2019/01/17</span>
        </span>
        
            <span class="fa-wrap">
                <i class="fa fa-eye"></i>
                <span id="busuanzi_value_page_pv"></span>
            </span>
        
    
</div>
            
            
            <p class="fa fa-exclamation-triangle warning">
                本文于<strong>520</strong>天之前发表，文中内容可能已经过时。
            </p>
        
    </div>
    
    <div class="post-body post-content">
        <h1 id="号拼接"><a href="#号拼接" class="headerlink" title="+号拼接"></a>+号拼接</h1><p>这种拼接最简单，也最容易被我们使用，因为它是不限编程语言的，比如Go语言有，Java也有，它们是+号运算符，在运行时计算的。现在演示下这种拼接的代码，虽然比较简单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func StringPlus() string&#123;</span><br><span class="line">	var s string</span><br><span class="line">	s+=&quot;昵称&quot;+&quot;:&quot;+&quot;飞雪无情&quot;+&quot;\n&quot;</span><br><span class="line">	s+=&quot;博客&quot;+&quot;:&quot;+&quot;http://www.flysnow.org/&quot;+&quot;\n&quot;</span><br><span class="line">	s+=&quot;微信公众号&quot;+&quot;:&quot;+&quot;flysnow_org&quot;</span><br><span class="line">	return s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以自己写个用例测试下，可以打印出和我们例子中一样的内容。那么这种最常见的字符串拼接的方式性能怎么样的呢，我们测试下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkStringPlus(b *testing.B) &#123;</span><br><span class="line">	for i:=0;i&lt;b.N;i++&#123;</span><br><span class="line">		StringPlus()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行<code>go test -bench=. -benchmem</code> 查看性能输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkStringPlus-8   20000000    108 ns/op   144 B/op    2 allocs/op</span><br></pre></td></tr></table></figure>

<p>每次操作需要108ns,进行2次内存分配，分配114字节的内存。</p>
<h1 id="fmt-拼接"><a href="#fmt-拼接" class="headerlink" title="fmt 拼接"></a>fmt 拼接</h1><p>这种拼接，借助于<code>fmt.Sprint</code>系列函数进行拼接，然后返回拼接的字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func StringFmt() string&#123;</span><br><span class="line">	return fmt.Sprint(&quot;昵称&quot;,&quot;:&quot;,&quot;飞雪无情&quot;,&quot;\n&quot;,&quot;博客&quot;,&quot;:&quot;,&quot;http://www.flysnow.org/&quot;,&quot;\n&quot;,&quot;微信公众号&quot;,&quot;:&quot;,&quot;flysnow_org&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkStringFmt(b *testing.B) &#123;</span><br><span class="line">	for i:=0;i&lt;b.N;i++&#123;</span><br><span class="line">		StringFmt()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行查看测试结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkStringFmt-8    5000000     385 ns/op   80 B/op     1 allocs/op</span><br></pre></td></tr></table></figure>

<p><font color="red">虽然每次操作内存分配只有1次，分配80字节也不多，但是每次操作耗时太长，性能远没有<code>+</code>号操作快。</font></p>
<h1 id="Join-拼接"><a href="#Join-拼接" class="headerlink" title="Join 拼接"></a>Join 拼接</h1><p>这个是利用<code>strings.Join</code>函数进行拼接，接受一个字符串数组，转换为一个拼接好的字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func StringJoin() string&#123;</span><br><span class="line">	s:=[]string&#123;&quot;昵称&quot;,&quot;:&quot;,&quot;飞雪无情&quot;,&quot;\n&quot;,&quot;博客&quot;,&quot;:&quot;,&quot;http://www.flysnow.org/&quot;,&quot;\n&quot;,&quot;微信公众号&quot;,&quot;:&quot;,&quot;flysnow_org&quot;&#125;</span><br><span class="line">	return strings.Join(s,&quot;&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkStringJoin(b *testing.B) &#123;</span><br><span class="line">	for i:=0;i&lt;b.N;i++&#123;</span><br><span class="line">		StringJoin()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了方便，把性能测试的代码放一起了，现在看看性能测试的效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkStringJoin-8   10000000    177 ns/op   160 B/op    2 allocs/op</span><br></pre></td></tr></table></figure>

<p><font color="red">整体和<code>+</code>操作相差不了太多，大概低0.5倍的样子。</font></p>
<h1 id="buffer-拼接"><a href="#buffer-拼接" class="headerlink" title="buffer 拼接"></a>buffer 拼接</h1><p>这种被用的也很多，使用的是<code>bytes.Buffer</code>进行的字符串拼接，它是非常灵活的一个结构体，不止可以拼接字符串，还是可以<code>byte,rune</code>等，并且实现了<code>io.Writer</code>接口，写入也非常方便。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func StringBuffer() string &#123;</span><br><span class="line">	var b bytes.Buffer</span><br><span class="line">	b.WriteString(&quot;昵称&quot;)</span><br><span class="line">	b.WriteString(&quot;:&quot;)</span><br><span class="line">	b.WriteString(&quot;飞雪无情&quot;)</span><br><span class="line">	b.WriteString(&quot;\n&quot;)</span><br><span class="line">	b.WriteString(&quot;博客&quot;)</span><br><span class="line">	b.WriteString(&quot;:&quot;)</span><br><span class="line">	b.WriteString(&quot;http://www.flysnow.org/&quot;)</span><br><span class="line">	b.WriteString(&quot;\n&quot;)</span><br><span class="line">	b.WriteString(&quot;微信公众号&quot;)</span><br><span class="line">	b.WriteString(&quot;:&quot;)</span><br><span class="line">	b.WriteString(&quot;flysnow_org&quot;)</span><br><span class="line">	return b.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkStringBuffer(b *testing.B) &#123;</span><br><span class="line">	for i:=0;i&lt;b.N;i++&#123;</span><br><span class="line">		StringBuffer()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看他的性能，运行输出即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkStringBuffer-8     5000000     291 ns/op   336 B/op    3 allocs/op</span><br></pre></td></tr></table></figure>

<p>好像并不是太好,和最差的fmt拼接差不多，和<code>+</code>号，Join拼接差好远，内存分配也比较多。每次操作耗时也很长。</p>
<h1 id="builder-拼接"><a href="#builder-拼接" class="headerlink" title="builder 拼接"></a>builder 拼接</h1><p>为了改进buffer拼接的性能，从go 1.10 版本开始，增加了一个builder类型，用于提升字符串拼接的性能。它的使用和buffer几乎一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func StringBuilder() string &#123;</span><br><span class="line">	var b strings.Builder</span><br><span class="line">	b.WriteString(&quot;昵称&quot;)</span><br><span class="line">	b.WriteString(&quot;:&quot;)</span><br><span class="line">	b.WriteString(&quot;飞雪无情&quot;)</span><br><span class="line">	b.WriteString(&quot;\n&quot;)</span><br><span class="line">	b.WriteString(&quot;博客&quot;)</span><br><span class="line">	b.WriteString(&quot;:&quot;)</span><br><span class="line">	b.WriteString(&quot;http://www.flysnow.org/&quot;)</span><br><span class="line">	b.WriteString(&quot;\n&quot;)</span><br><span class="line">	b.WriteString(&quot;微信公众号&quot;)</span><br><span class="line">	b.WriteString(&quot;:&quot;)</span><br><span class="line">	b.WriteString(&quot;flysnow_org&quot;)</span><br><span class="line">	return b.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkStringBuilder(b *testing.B) &#123;</span><br><span class="line">	for i:=0;i&lt;b.N;i++&#123;</span><br><span class="line">		StringBuilder()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>官方都说比buffer性能好了，我们看看性能测试的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkStringBuilder-8    10000000    170 ns/op   232 B/op    4 allocs/op</span><br></pre></td></tr></table></figure>

<p>的确提升了，提升了一倍，虽然每次分配的内存次数有点多，但是每次分配的内存大小比buffer要少。</p>
<h1 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h1><p>以上就是常用的字符串拼接的方式，现在我们把这些测试结果，汇总到一起，对比下看看,因为Benchmark的测试，对于性能只显示，我把测试的时间设置为3s（秒），把时间拉长便于对比测试，同时生成了cpu profile文件，用于性能分析。</p>
<p>运行<code>go test xx.go -bench=. -benchmem -benchtime=3s -cpuprofile=profile.out</code>得到如下测试结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringPlus-8    50000000    112 ns/op   144 B/op    2 allocs/op</span><br><span class="line">StringFmt-8     20000000    344 ns/op   80 B/op     1 allocs/op</span><br><span class="line">StringJoin-8    30000000    171 ns/op   160 B/op    2 allocs/op</span><br><span class="line">StringBuffer-8  20000000    302 ns/op   336 B/op    3 allocs/op</span><br><span class="line">StringBuilder-8 30000000    171 ns/op   232 B/op    4 allocs/op</span><br></pre></td></tr></table></figure>

<p>我们通过<code>go tool pprof profile.out</code> 看下我们输出的cpu profile信息。这里主要使用top命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Showing top 15 nodes out of 89</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">    11.99s 42.55% 42.55%     11.99s 42.55%  runtime.kevent</span><br><span class="line">     6.30s 22.36% 64.90%      6.30s 22.36%  runtime.pthread_cond_wait</span><br><span class="line">     1.65s  5.86% 70.76%      1.65s  5.86%  runtime.pthread_cond_signal</span><br><span class="line">     1.11s  3.94% 74.70%      1.11s  3.94%  runtime.usleep</span><br><span class="line">     1.10s  3.90% 78.60%      1.10s  3.90%  runtime.pthread_cond_timedwait_relative_np</span><br><span class="line">     0.58s  2.06% 80.66%      0.62s  2.20%  runtime.wbBufFlush1</span><br><span class="line">     0.51s  1.81% 82.47%      0.51s  1.81%  runtime.memmove</span><br><span class="line">     0.44s  1.56% 84.03%      1.81s  6.42%  fmt.(*pp).printArg</span><br><span class="line">     0.39s  1.38% 85.42%      2.36s  8.37%  fmt.(*pp).doPrint</span><br><span class="line">     0.36s  1.28% 86.69%      0.70s  2.48%  fmt.(*buffer).WriteString (inline)</span><br><span class="line">     0.34s  1.21% 87.90%      0.93s  3.30%  runtime.mallocgc</span><br><span class="line">     0.20s  0.71% 88.61%      1.20s  4.26%  fmt.(*fmt).fmtS</span><br><span class="line">     0.18s  0.64% 89.25%      0.18s  0.64%  fmt.(*fmt).truncate</span><br><span class="line">     0.16s  0.57% 89.82%      0.16s  0.57%  runtime.memclrNoHeapPointers</span><br><span class="line">     0.15s  0.53% 90.35%      1.35s  4.79%  fmt.(*pp).fmtString</span><br></pre></td></tr></table></figure>

<p>前15个，可以看到fmt拼接的方式是最差的，因为fmt里很多方法耗时排在了最前面。buffer的WriteString方法也比较耗时。</p>
<p>以上的TOP可能还不是太直观，如果大家看火焰图的话，就会更清晰。性能最好的是<code>+</code>号拼接、Join拼接，最慢的是fmt拼接，这里的builder和buffer拼接差不多，并没有发挥出其能力。</p>
<h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><p>从整个性能的测试和分析来看，我们期待的builder并没有发挥出来，这是不是意味着builder不实用了呢？还不如+号和Join拼接呢？继续接着分析,猜测可能原因如下：</p>
<ul>
<li>拼接的字符串大小</li>
<li>拼接的字符串数量</li>
</ul>
<h1 id="拼接函数改造"><a href="#拼接函数改造" class="headerlink" title="拼接函数改造"></a>拼接函数改造</h1><p>前面提到了2种可能的猜测，拼接字符串的数量和拼接字符串的大小，现在我们就开始证明这两种情况，为了演示方便，我们把原来的拼接函数修改一下，可以接受一个[]string类型的参数，这样我们就可以对切片数组进行字符串拼接，这里直接给出所有的拼接方法的改造后实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">func StringPlus(p []string) string&#123;</span><br><span class="line">	var s string</span><br><span class="line">	l:=len(p)</span><br><span class="line">	for i:=0;i&lt;l;i++&#123;</span><br><span class="line">		s+=p[i]</span><br><span class="line">	&#125;</span><br><span class="line">	return s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func StringFmt(p []interface&#123;&#125;) string&#123;</span><br><span class="line">	return fmt.Sprint(p...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func StringJoin(p []string) string&#123;</span><br><span class="line">	return strings.Join(p,&quot;&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func StringBuffer(p []string) string &#123;</span><br><span class="line">	var b bytes.Buffer</span><br><span class="line">	l:=len(p)</span><br><span class="line">	for i:=0;i&lt;l;i++&#123;</span><br><span class="line">		b.WriteString(p[i])</span><br><span class="line">	&#125;</span><br><span class="line">	return b.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func StringBuilder(p []string) string &#123;</span><br><span class="line">	var b strings.Builder</span><br><span class="line">	l:=len(p)</span><br><span class="line">	for i:=0;i&lt;l;i++&#123;</span><br><span class="line">		b.WriteString(p[i])</span><br><span class="line">	&#125;</span><br><span class="line">	return b.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h1><p>以上的字符串拼接函数修改后，我们就可以构造不同大小的切片进行字符串拼接测试了。为了模拟上次的效果，我们先用10个切片大小的字符串进行拼接测试。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const BLOG  = &quot;http://www.flysnow.org/&quot;</span><br><span class="line"></span><br><span class="line">func initStrings(N int) []string&#123;</span><br><span class="line">	s:=make([]string,N)</span><br><span class="line">	for i:=0;i&lt;N;i++&#123;</span><br><span class="line">		s[i]=BLOG</span><br><span class="line">	&#125;</span><br><span class="line">	return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func initStringi(N int) []interface&#123;&#125;&#123;</span><br><span class="line">	s:=make([]interface&#123;&#125;,N)</span><br><span class="line">	for i:=0;i&lt;N;i++&#123;</span><br><span class="line">		s[i]=BLOG</span><br><span class="line">	&#125;</span><br><span class="line">	return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是两个构建测试用例切片数组的函数，可以生成N个大小的切片。第二个initStringi函数返回的是[]interface{}，这是专门为StringFmt(p []interface{})拼接函数准备的，减少类型之间的转换。</p>
<p>有了这两个生成测试用例的函数，我们就可以构建我们的Go语言性能测试了，我们先测试10个大小的切片。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkStringPlus10(b *testing.B) &#123;</span><br><span class="line">	p:= initStrings(10)</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	for i:=0;i&lt;b.N;i++&#123;</span><br><span class="line">		StringPlus(p)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkStringFmt10(b *testing.B) &#123;</span><br><span class="line">	p:= initStringi(10)</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	for i:=0;i&lt;b.N;i++&#123;</span><br><span class="line">		StringFmt(p)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkStringJoin10(b *testing.B) &#123;</span><br><span class="line">	p:= initStrings(10)</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	for i:=0;i&lt;b.N;i++&#123;</span><br><span class="line">		StringJoin(p)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkStringBuffer10(b *testing.B) &#123;</span><br><span class="line">	p:= initStrings(10)</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	for i:=0;i&lt;b.N;i++&#123;</span><br><span class="line">		StringBuffer(p)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkStringBuilder10(b *testing.B) &#123;</span><br><span class="line">	p:= initStrings(10)</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	for i:=0;i&lt;b.N;i++&#123;</span><br><span class="line">		StringBuilder(p)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在每个性能测试函数中，我们都会调用b.ResetTimer()，这是为了避免测试用例准备时间不同，带来的性能测试效果偏差问题<br>我们运行<code>go test -bench=. -run=NONE -benchmem</code> 查看结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkStringPlus10-8     3000000     593 ns/op   1312 B/op   9 allocs/op</span><br><span class="line">BenchmarkStringFmt10-8      5000000     335 ns/op   240 B/op    1 allocs/op</span><br><span class="line">BenchmarkStringJoin10-8     10000000    200 ns/op   480 B/op    2 allocs/op</span><br><span class="line">BenchmarkStringBuffer10-8   3000000     452 ns/op   864 B/op    4 allocs/op</span><br><span class="line">BenchmarkStringBuilder10-8  10000000    231 ns/op   480 B/op    4 allocs/op</span><br></pre></td></tr></table></figure>

<p>通过这次我们可以看到，<code>+</code>号拼接不再具有优势，因为string是不可变的，每次拼接都会生成一个新的<code>string</code>,也就是会进行一次内存分配，我们现在是10个大小的切片，每次操作要进行9次进行分配，占用内存，所以每次操作时间都比较长，自然性能就低下。</p>
<p>文章上面关于<code>+</code>拼接还有印象，<code>+</code>加号拼接的性能测试中显示的只有2次内存分配，但是我们用了好多个<code>+</code>的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func StringPlus() string&#123;</span><br><span class="line">	var s string</span><br><span class="line">	s+=&quot;昵称&quot;+&quot;:&quot;+&quot;飞雪无情&quot;+&quot;\n&quot;</span><br><span class="line">	s+=&quot;博客&quot;+&quot;:&quot;+&quot;http://www.flysnow.org/&quot;+&quot;\n&quot;</span><br><span class="line">	s+=&quot;微信公众号&quot;+&quot;:&quot;+&quot;flysnow_org&quot;</span><br><span class="line">	return s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来回顾下这段代码，的确是有很多+的，但是只有2次内存分配，我们可以大胆猜测,是3次s+=导致的，正常和我们今天测试的10个长度的切片，只有9次内存分配一样。下面我们通过运行如下命令看下Go编译器对这段代码的优化：<code>go build -gcflags=&quot;-m -m&quot; main.go</code>,输出中有如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">can inline StringPlus as: func() string &#123; var s string; s = &lt;N&gt;; s += &quot;昵称:飞雪无情\n&quot;; s += &quot;博客:http://www.flysnow.org/\n&quot;; s += &quot;微信公众号:flysnow_org&quot;; return s &#125;</span><br></pre></td></tr></table></figure>

<p>现在一目了然了，其实是编译器帮我们把字符串做了优化，只剩下3个<code>s+=</code></p>
<p>这次，采用长度为10个切片进行测试，也很明显测试出了Builder要比Buffer性能好很多，这个问题原因主要还是<code>[]byte</code>和<code>string</code>之间的转换，<code>Builder</code>恰恰解决了这个问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (b *Builder) String() string &#123;</span><br><span class="line">	return *(*string)(unsafe.Pointer(&amp;b.buf))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很高效的解决方案。</p>
<h1 id="100个字符串"><a href="#100个字符串" class="headerlink" title="100个字符串"></a>100个字符串</h1><p>现在我们测试下100个字符串拼接的情况，对于我们上面的代码，要改造非常容易，这里直接给出测试代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkStringPlus100(b *testing.B) &#123;</span><br><span class="line">	p:= initStrings(100)</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	for i:=0;i&lt;b.N;i++&#123;</span><br><span class="line">		StringPlus(p)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkStringFmt100(b *testing.B) &#123;</span><br><span class="line">	p:= initStringi(100)</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	for i:=0;i&lt;b.N;i++&#123;</span><br><span class="line">		StringFmt(p)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkStringJoin100(b *testing.B) &#123;</span><br><span class="line">	p:= initStrings(100)</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	for i:=0;i&lt;b.N;i++&#123;</span><br><span class="line">		StringJoin(p)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkStringBuffer100(b *testing.B) &#123;</span><br><span class="line">	p:= initStrings(100)</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	for i:=0;i&lt;b.N;i++&#123;</span><br><span class="line">		StringBuffer(p)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkStringBuilder100(b *testing.B) &#123;</span><br><span class="line">	p:= initStrings(100)</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	for i:=0;i&lt;b.N;i++&#123;</span><br><span class="line">		StringBuilder(p)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在运行性能测试，看看100个字符串连接的性能怎么样，哪个函数最高效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkStringPlus100-8    100000  19711 ns/op     123168 B/op     99 allocs/op</span><br><span class="line">BenchmarkStringFmt100-8     500000  2615 ns/op      2304 B/op       1 allocs/op</span><br><span class="line">BenchmarkStringJoin100-8    1000000 1516 ns/op      4608 B/op       2 allocs/op</span><br><span class="line">BenchmarkStringBuffer100-8  500000  2333 ns/op      8112 B/op       7 allocs/op</span><br><span class="line">BenchmarkStringBuilder100-8 1000000 1714 ns/op      6752 B/op       8 allocs/op</span><br></pre></td></tr></table></figure>

<p><code>+</code>号和我们上面分析得一样，这次是99次内存分配，性能体验越来越差，在后面的测试中，会排除掉。</p>
<p><code>fmt</code>和<code>bufrer</code>已经的性能也没有提升，继续走低。剩下比较坚挺的是<code>Join</code>和<code>Builder</code>。</p>
<h1 id="1000-个字符串。"><a href="#1000-个字符串。" class="headerlink" title="1000 个字符串。"></a>1000 个字符串。</h1><p>测试用力和上面章节的大同小异，所以我们直接看测试结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkStringPlus1000-8       1000    1611985 ns/op   12136228 B/op   999 allocs/op</span><br><span class="line">BenchmarkStringFmt1000-8        50000   28510 ns/op     24590 B/op      1 allocs/op</span><br><span class="line">BenchmarkStringJoin1000-8       100000  15050 ns/op     49152 B/op      2 allocs/op</span><br><span class="line">BenchmarkStringBuffer1000-8     100000  23534 ns/op     122544 B/op     11 allocs/op</span><br><span class="line">BenchmarkStringBuilder1000-8    100000  17996 ns/op     96224 B/op      16 allocs/op</span><br></pre></td></tr></table></figure>

<p>整体和100个字符串的时候差不多，表现好的还是<code>Join</code>和<code>Builder</code>。这两个方法的使用侧重点有些不一样， 如果有现成的数组、切片那么可以直接使用<code>Join</code>,但是如果没有，并且追求灵活性拼接，还是选择<code>Builder</code>。 <code>Join</code>还是定位于有现成切片、数组的（毕竟拼接成数组也要时间），并且使用固定方式进行分解的，比如逗号、空格等，局限比较大。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>至于10000个字符串拼接我这里就不做测试了，大家可以自己试试，看看是不是大同小异的。</p>
<p>从最近的这两篇文章的分析来看，我们大概可以总结出。</p>
<ul>
<li><ul>
<li>连接适用于短小的、常量字符串（明确的，非变量），因为编译器会给我们优化。</li>
</ul>
</li>
<li>Join是比较统一的拼接，不太灵活</li>
<li>fmt和buffer基本上不推荐</li>
<li>builder从性能和灵活性上，都是上佳的选择。</li>
</ul>
<h1 id="Builder-慢在哪"><a href="#Builder-慢在哪" class="headerlink" title="Builder 慢在哪"></a>Builder 慢在哪</h1><p>在前面可以看出来少量拼接，<code>builder</code>并不明显，那么到底慢在哪里呢？既然要优化Builder拼接，那么我们起码知道他慢在哪，我们继续使用我们上篇文章的测试用例，运行看下性能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Builder10-8     5000000     258 ns/op       480 B/op        4 allocs/op</span><br><span class="line">Builder100-8    1000000     2012 ns/op      6752 B/op       8 allocs/op</span><br><span class="line">Builder1000-8   100000      21016 ns/op     96224 B/op      16 allocs/op</span><br><span class="line">Builder10000-8  10000       195098 ns/op    1120226 B/op    25 allocs/op</span><br></pre></td></tr></table></figure>

<p>针对既然要优化<code>Builder</code>拼接,采取了10、100、1000、10000四种不同数量的字符串进行拼接测试。我们发现每次操作都有不同次数的内存分配，内存分配越多，越慢，如果引起GC，就更慢了，首先我们先优化这个，减少内存分配的次数。</p>
<h1 id="内存分配优化"><a href="#内存分配优化" class="headerlink" title="内存分配优化"></a>内存分配优化</h1><p>通过cpuprofile，查看生成的火焰图可以得知，<code>runtime.growslice</code>函数会被频繁的调用，并且时间占比也比较长。我们查看<code>Builder.WriteString</code>的源代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func (b *Builder) WriteString(s string) (int, error) &#123;</span><br><span class="line">	b.copyCheck()</span><br><span class="line">	b.buf = append(b.buf, s...)</span><br><span class="line">	return len(s), nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以肯定是<code>append</code>方法触发了<code>runtime.growslice</code>，因为<code>b.buf</code>的容量<code>cap</code>不足，所以需要调用<code>runtime.growslice</code>扩充<code>b.buf</code>的容量，然后才可以追加新的元素<code>s...</code>。扩容容量自然会涉及到内存的分配，而且追加的内容越多，内存分配的次数越多，这和我们上面性能测试的数据是一样的。</p>
<p>既然问题的原因找到了，那么我们就可以优化了，核心手段就是减少<code>runtime.growslice</code>调用，甚至不调用。照着这个思路的话，我们就要提前为<code>b.buf</code>分配好容量<code>cap</code>。幸好<code>Builder</code>为我们提供了扩充容量的方法<code>Grow</code>，我们在进行<code>WriteString</code>之前，先通过<code>Grow</code>方法，扩充好容量即可。</p>
<p>现在开始改造我们的StringBuilder函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func StringBuilder(p []string,cap int) string &#123;</span><br><span class="line">	var b strings.Builder</span><br><span class="line">	l:=len(p)</span><br><span class="line">	b.Grow(cap)</span><br><span class="line">	for i:=0;i&lt;l;i++&#123;</span><br><span class="line">		b.WriteString(p[i])</span><br><span class="line">	&#125;</span><br><span class="line">	return b.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加一个参数<code>cap</code>，让使用者告诉我们需要的容量大小。<code>Grow</code>方法的实现非常简单，就是一个通过<code>make</code>函数，扩充<code>b.buf</code>大小，然后再拷贝<code>b.buf</code>的过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func (b *Builder) grow(n int) &#123;</span><br><span class="line">	buf := make([]byte, len(b.buf), 2*cap(b.buf)+n)</span><br><span class="line">	copy(buf, b.buf)</span><br><span class="line">	b.buf = buf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么现在我们的性能测试用例变成如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkStringBuilder10(b *testing.B) &#123;</span><br><span class="line">	p:= initStrings(10)</span><br><span class="line">	cap:=10*len(BLOG)</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	for i:=0;i&lt;b.N;i++&#123;</span><br><span class="line">		StringBuilder(p,cap)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkStringBuilder1000(b *testing.B) &#123;</span><br><span class="line">	p:= initStrings(1000)</span><br><span class="line">	cap:=1000*len(BLOG)</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	for i:=0;i&lt;b.N;i++&#123;</span><br><span class="line">		StringBuilder(p,cap)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了说明情况和简短代码，这里只有10和1000个元素的用例，其他类似。为了把性能优化到极致，我一次性把需要的容量分配足够。现在我们再运行性能（Benchmark）测试代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Builder10-8     10000000    123 ns/op       352 B/op    1 allocs/op</span><br><span class="line">Builder100-8    2000000     898 ns/op       2688 B/op   1 allocs/op</span><br><span class="line">Builder1000-8   200000      7729 ns/op      24576 B/op  1 allocs/op</span><br><span class="line">Builder10000-8  20000       78678 ns/op     237568 B/op 1 allocs/op</span><br></pre></td></tr></table></figure>

<p>性能足足翻了1倍多，只有1次内存分配，每次操作占用的内存也减少了一半多，降低了GC。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>背后的原理也非常清楚，就是预先分配内存，减少append过程中的内存重新分配和数据拷贝，这样我们就可以提升很多的性能。所以对于可以预见的长度的切，都可以提前申请申请好内存。</p>
<blockquote>
<p>本文收集来源：<a href="https://www.flysnow.org" target="_blank" rel="noopener">https://www.flysnow.org</a></p>
</blockquote>

    </div>
    
    <div class="post-footer">
        <div>
            
                转载声明：转载请注明出处，如有侵权请联系 © <a href="mailto:abner510@126.com" target="_blank">abner-xu</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/2019/01/18/Go/base3.切片/" class="pre-post btn btn-default" title='Go基础-切片'>
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">Go基础-切片</span>
        </a>
    
    
        <a href="/2019/01/16/Go/base1.iota/" class="next-post btn btn-default" title='Go基础-iota'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">Go基础-iota</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
   <p>评论系统未开启，无法评论！</p>

    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-xs-6 col-sm-3">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#号拼接"><span class="toc-text">+号拼接</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fmt-拼接"><span class="toc-text">fmt 拼接</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Join-拼接"><span class="toc-text">Join 拼接</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#buffer-拼接"><span class="toc-text">buffer 拼接</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#builder-拼接"><span class="toc-text">builder 拼接</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#性能对比"><span class="toc-text">性能对比</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#疑问"><span class="toc-text">疑问</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#拼接函数改造"><span class="toc-text">拼接函数改造</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#测试用例"><span class="toc-text">测试用例</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#100个字符串"><span class="toc-text">100个字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1000-个字符串。"><span class="toc-text">1000 个字符串。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Builder-慢在哪"><span class="toc-text">Builder 慢在哪</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#内存分配优化"><span class="toc-text">内存分配优化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
        访问量:
        <strong id="busuanzi_value_site_pv">
            <i class="fa fa-spinner fa-spin"></i>
        </strong>
        &nbsp; | &nbsp;
        访客数:
        <strong id="busuanzi_value_site_uv">
            <i class="fa fa-spinner fa-spin"></i>
        </strong>
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2019
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>






    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>